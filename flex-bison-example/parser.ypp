/* Parses records containing a number and zero or more subrecords */
%{
#include <stdint.h>
#include <FlexLexer.h>
#include <string>
#include <list>
#include "data.h"

using namespace std;

int yyerror(const char *s);
int yylex();

static list<Record>* results;
%}

%union
{
    int ival;
    Record recval;
    list<Record>* reclist;
}

%defines

%token <ival> NUM
%token OPEN
%token CLOSE

%type <recval> record
%type <reclist> records

%%

/* The input file consists of a list of zero or more records. */
file : records
        { results = $1; }
;

records : /* Zero records is okay */
        { $$ = new list<Record>; }
    | records record
        { $1->push_back($2);
          $$ = $1;
        }
;

record : OPEN NUM records CLOSE
        { $$.num = $2;
          $$.data = $3;
        }
   | OPEN records CLOSE         /* The number is optional and defaults to -1 */
        { $$.num = -1;
          $$.data = $2;
        }
;

%%

static FlexLexer *lexer;

int yyerror(const char * s)
{
   cerr << "Parse error: " << s << endl;
   return 0;
}

int yylex()
{
   return lexer->yylex();
}

list<Record>* parse_test(istream &datafile)
{
   // Construct the lexer.
   lexer = new yyFlexLexer(&datafile);
   // Run the parser.
   if(yyparse())
   {
       cerr << "Parse failed!" << endl;
       exit(1);
   }

   delete lexer;
   return results;
}
